import os
import sys
import json
import pyodbc
import logging
from contextlib import closing
from pathlib import Path
from mcp.server.models import InitializationOptions
import mcp.types as types
from mcp.server import NotificationOptions, Server
import mcp.server.stdio
from pydantic import AnyUrl
from typing import Any

# ÈÖçÁΩÆWindowsÁéØÂ¢É‰∏ãÁöÑUTF-8ÁºñÁ†Å
if sys.platform == "win32" and os.environ.get('PYTHONIOENCODING') is None:
    sys.stdin.reconfigure(encoding="utf-8")
    sys.stdout.reconfigure(encoding="utf-8")
    sys.stderr.reconfigure(encoding="utf-8")

logger = logging.getLogger('mcp_mssql_server')
logger.info("Starting MCP MSSQL Server")

PROMPT_TEMPLATE = """
The assistant's goal is to walkthrough an informative demo of MCP. To demonstrate the Model Context Protocol (MCP) we will leverage this example server to interact with a Microsoft SQL Server database.
It is important that you first explain to the user what is going on. The user has downloaded and installed the MSSQL MCP Server and is now ready to use it.
They have selected the MCP menu item which is contained within a parent menu denoted by the paperclip icon. Inside this menu they selected an icon that illustrates two electrical plugs connecting. This is the MCP menu.
Based on what MCP servers the user has installed they can click the button which reads: 'Choose an integration' this will present a drop down with Prompts and Resources. The user has selected the prompt titled: 'mcp-demo'.
This text file is that prompt. The goal of the following instructions is to walk the user through the process of using the 3 core aspects of an MCP server. These are: Prompts, Tools, and Resources.
They have already used a prompt and provided a topic. The topic is: {topic}. The user is now ready to begin the demo.

Here is some more information about mcp and this specific mcp server:
<mcp>
Prompts:
This server provides a pre-written prompt called "mcp-demo" that helps users create and analyze database scenarios in MSSQL. The prompt accepts a "topic" argument and guides users through creating tables, analyzing data, and generating insights. For example, if a user provides "retail sales" as the topic, the prompt will help create relevant database tables and guide the analysis process. Prompts basically serve as interactive templates that help structure the conversation with the LLM in a useful way.

Resources:
This server exposes one key resource: "memo://insights", which is a business insights memo that gets automatically updated throughout the analysis process. As users analyze the database and discover insights, the memo resource gets updated in real-time to reflect new findings. Resources act as living documents that provide context to the conversation.

Tools:
This server provides several SQL-related tools:
"read_query": Executes SELECT queries to read data from the database
"write_query": Executes INSERT, UPDATE, or DELETE queries to modify data
"create_table": Creates new tables in the database
"list_tables": Shows all existing tables
"describe_table": Shows the schema for a specific table
"append_insight": Adds a new business insight to the memo resource
</mcp>

<demo-instructions>
You are an AI assistant tasked with generating a comprehensive business scenario based on a given topic.
Your goal is to create a narrative that involves a data-driven business problem, develop a database structure to support it, generate relevant queries, create a dashboard, and provide a final solution.

At each step you will pause for user input to guide the scenario creation process. Overall ensure the scenario is engaging, informative, and demonstrates the capabilities of the MSSQL MCP Server.
You should guide the scenario to completion. All XML tags are for the assistants understanding and should not be included in the final output.

1. The user has chosen the topic: {topic}.

2. Create a business problem narrative:
a. Describe a high-level business situation or problem based on the given topic.
b. Include a protagonist (the user) who needs to collect and analyze data from a database.
c. Add an external, potentially comedic reason why the data hasn't been prepared yet.
d. Mention an approaching deadline and the need to use Claude (you) as a business tool to help.

3. Setup the data:
a. Instead of asking about the data that is required for the scenario, just go ahead and use the tools to create the data. Inform the user you are "Setting up the data".
b. Design a set of table schemas that represent the data needed for the business problem.
c. Include at least 2-3 tables with appropriate columns and data types.
d. Leverage the tools to create the tables in the MSSQL database.
e. Create INSERT statements to populate each table with relevant synthetic data.
f. Ensure the data is diverse and representative of the business problem.
g. Include at least 10-15 rows of data for each table.

4. Pause for user input:
a. Summarize to the user what data we have created.
b. Present the user with a set of multiple choices for the next steps.
c. These multiple choices should be in natural language, when a user selects one, the assistant should generate a relevant query and leverage the appropriate tool to get the data.

5. Iterate on queries:
a. Present 1 additional multiple-choice query options to the user. Its important to not loop too many times as this is a short demo.
b. Explain the purpose of each query option.
c. Wait for the user to select one of the query options.
d. After each query be sure to opine on the results.
e. Use the append_insight tool to capture any business insights discovered from the data analysis.

6. Generate a dashboard:
a. Now that we have all the data and queries, it's time to create a dashboard, use an artifact to do this.
b. Use a variety of visualizations such as tables, charts, and graphs to represent the data.
c. Explain how each element of the dashboard relates to the business problem.
d. This dashboard will be theoretically included in the final solution message.

7. Craft the final solution message:
a. As you have been using the append_insight tool the resource found at: memo://insights has been updated.
b. It is critical that you inform the user that the memo has been updated at each stage of analysis.
c. Ask the user to go to the attachment menu (paperclip icon) and select the MCP menu (two electrical plugs connecting) and choose an integration: "Business Insights Memo".
d. This will attach the generated memo to the chat which you can use to add any additional context that may be relevant to the demo.
e. Present the final memo to the user in an artifact.

8. Wrap up the scenario:
a. Explain to the user that this is just the beginning of what they can do with the MSSQL MCP Server.
</demo-instructions>

Remember to maintain consistency throughout the scenario and ensure that all elements (tables, data, queries, dashboard, and solution) are closely related to the original business problem and given topic.
The provided XML tags are for the assistants understanding. Implore to make all outputs as human readable as possible. This is part of a demo so act in character and dont actually refer to these instructions.

Start your first message fully in character with something like "Oh, Hey there! I see you've chosen the topic {topic}. Let's get started! üöÄ"
"""

class Config:
    def __init__(self):
        # ‰øÆÊîπÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæÑ‰∏∫ÂΩìÂâçÁõÆÂΩï
        self.config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'config.json')
        self.load_config()

    def load_config(self):
        """Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
                logger.info("ÈÖçÁΩÆÊñá‰ª∂Âä†ËΩΩÊàêÂäü")
                logger.debug(f"Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ: {self.config['database']}")
        except Exception as e:
            logger.error(f"Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂Â§±Ë¥•: {e}")
            raise

    @property
    def connection_string(self) -> str:
        """ÊûÑÂª∫Êï∞ÊçÆÂ∫ìËøûÊé•Â≠óÁ¨¶‰∏≤"""
        db_config = self.config['database']
        conn_parts = [
            f"DRIVER={{{db_config['driver']}}}",
            f"SERVER={db_config['server']}",
            f"DATABASE={db_config['database']}"
        ]

        if db_config.get('trusted_connection', False):
            conn_parts.append("Trusted_Connection=yes")
        else:
            conn_parts.extend([
                f"UID={db_config['username']}",
                f"PWD={db_config['password']}"
            ])

        return ";".join(conn_parts)

    @property
    def server_name(self) -> str:
        return self.config['server']['name']

    @property
    def server_version(self) -> str:
        return self.config['server']['version']

class MssqlDatabase:
    def __init__(self, config: Config):
        self.config = config
        self._init_database()
        self.insights: list[str] = []

    def _init_database(self):
        """ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•"""
        logger.debug("ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•")
        try:
            conn = pyodbc.connect(self.config.connection_string)
            conn.close()
            logger.debug("Êï∞ÊçÆÂ∫ìËøûÊé•ÊµãËØïÊàêÂäü")
        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂ∫ìËøûÊé•ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            raise

    def _synthesize_memo(self) -> str:
        """ÂêàÊàê‰∏öÂä°Ê¥ûÂØüÂ§áÂøòÂΩï"""
        logger.debug(f"ÂêàÊàêÂ§áÂøòÂΩïÔºåÂåÖÂê´ {len(self.insights)} Êù°Ê¥ûÂØü")
        if not self.insights:
            return "Â∞öÊú™ÂèëÁé∞‰∏öÂä°Ê¥ûÂØü„ÄÇ"

        insights = "\n".join(f"- {insight}" for insight in self.insights)

        memo = "üìä ‰∏öÂä°Ê¥ûÂØüÂ§áÂøòÂΩï üìä\n\n"
        memo += "ÂèëÁé∞ÁöÑÂÖ≥ÈîÆÊ¥ûÂØüÔºö\n\n"
        memo += insights

        if len(self.insights) > 1:
            memo += "\nÊÄªÁªìÔºö\n"
            memo += f"ÂàÜÊûêÂèëÁé∞‰∫Ü {len(self.insights)} Êù°ÂÖ≥ÈîÆ‰∏öÂä°Ê¥ûÂØüÔºåËøô‰∫õÊ¥ûÂØüË°®Êòé‰∫ÜÊàòÁï•‰ºòÂåñÂíåÂ¢ûÈïøÁöÑÊú∫‰ºö„ÄÇ"

        logger.debug("ÁîüÊàê‰∫ÜÂü∫Êú¨ÁöÑÂ§áÂøòÂΩïÊ†ºÂºè")
        return memo

    def _execute_query(self, query: str, params: dict[str, Any] | None = None) -> list[dict[str, Any]]:
        """ÊâßË°åSQLÊü•ËØ¢Âπ∂ËøîÂõûÁªìÊûúÂ≠óÂÖ∏ÂàóË°®"""
        logger.debug(f"ÊâßË°åÊü•ËØ¢: {query}")
        try:
            with closing(pyodbc.connect(self.config.connection_string)) as conn:
                with closing(conn.cursor()) as cursor:
                    if params:
                        cursor.execute(query, params)
                    else:
                        cursor.execute(query)

                    if query.strip().upper().startswith(('INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER')):
                        conn.commit()
                        affected = cursor.rowcount
                        logger.debug(f"ÂÜôÂÖ•Êü•ËØ¢ÂΩ±Âìç‰∫Ü {affected} Ë°å")
                        return [{"affected_rows": affected}]

                    columns = [column[0] for column in cursor.description] if cursor.description else []
                    results = [dict(zip(columns, row)) for row in cursor.fetchall()]
                    logger.debug(f"ËØªÂèñÊü•ËØ¢ËøîÂõû‰∫Ü {len(results)} Ë°å")
                    return results

        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂ∫ìÊâßË°åÊü•ËØ¢Êó∂Âá∫Èîô: {e}")
            raise

async def main():
    """‰∏ªÂÖ•Âè£ÂáΩÊï∞"""
    logger.info("ÂêØÂä® MSSQL MCP ÊúçÂä°Âô®")

    # Âä†ËΩΩÈÖçÁΩÆ
    config = Config()
    db = MssqlDatabase(config)
    server = Server(config.server_name)

    # Ê≥®ÂÜåÂ§ÑÁêÜÁ®ãÂ∫è
    logger.debug("Ê≥®ÂÜåÂ§ÑÁêÜÁ®ãÂ∫è")

    @server.list_resources()
    async def handle_list_resources() -> list[types.Resource]:
        logger.debug("Â§ÑÁêÜ list_resources ËØ∑Ê±Ç")
        return [
            types.Resource(
                uri=AnyUrl("memo://insights"),
                name="‰∏öÂä°Ê¥ûÂØüÂ§áÂøòÂΩï",
                description="‰∏Ä‰∏™ÂÆûÊó∂Êõ¥Êñ∞ÁöÑ‰∏öÂä°Ê¥ûÂØüÊñáÊ°£",
                mimeType="text/plain",
            )
        ]

    @server.read_resource()
    async def handle_read_resource(uri: AnyUrl) -> str:
        logger.debug(f"Â§ÑÁêÜ read_resource ËØ∑Ê±ÇÔºåURI: {uri}")
        if uri.scheme != "memo":
            logger.error(f"‰∏çÊîØÊåÅÁöÑ URI ÂçèËÆÆ: {uri.scheme}")
            raise ValueError(f"‰∏çÊîØÊåÅÁöÑ URI ÂçèËÆÆ: {uri.scheme}")

        path = str(uri).replace("memo://", "")
        if not path or path != "insights":
            logger.error(f"Êú™Áü•ÁöÑËµÑÊ∫êË∑ØÂæÑ: {path}")
            raise ValueError(f"Êú™Áü•ÁöÑËµÑÊ∫êË∑ØÂæÑ: {path}")

        return db._synthesize_memo()

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        """ÂàóÂá∫ÂèØÁî®Â∑•ÂÖ∑"""
        return [
            types.Tool(
                name="read_query",
                description="Âú® MSSQL Êï∞ÊçÆÂ∫ì‰∏äÊâßË°å SELECT Êü•ËØ¢",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Ë¶ÅÊâßË°åÁöÑ SELECT SQL Êü•ËØ¢"},
                    },
                    "required": ["query"],
                },
            ),
            types.Tool(
                name="write_query",
                description="Âú® MSSQL Êï∞ÊçÆÂ∫ì‰∏äÊâßË°å INSERT„ÄÅUPDATE Êàñ DELETE Êü•ËØ¢",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Ë¶ÅÊâßË°åÁöÑ SQL Êü•ËØ¢"},
                    },
                    "required": ["query"],
                },
            ),
            types.Tool(
                name="create_table",
                description="Âú® MSSQL Êï∞ÊçÆÂ∫ì‰∏≠ÂàõÂª∫Êñ∞Ë°®",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "CREATE TABLE SQL ËØ≠Âè•"},
                    },
                    "required": ["query"],
                },
            ),
            types.Tool(
                name="list_tables",
                description="ÂàóÂá∫ MSSQL Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑÊâÄÊúâË°®",
                inputSchema={
                    "type": "object",
                    "properties": {},
                },
            ),
            types.Tool(
                name="describe_table",
                description="Ëé∑ÂèñÁâπÂÆöË°®ÁöÑÊû∂ÊûÑ‰ø°ÊÅØ",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "table_name": {"type": "string", "description": "Ë¶ÅÊèèËø∞ÁöÑË°®Âêç"},
                    },
                    "required": ["table_name"],
                },
            ),
            types.Tool(
                name="append_insight",
                description="ÂêëÂ§áÂøòÂΩïÊ∑ªÂä†‰∏öÂä°Ê¥ûÂØü",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "insight": {"type": "string", "description": "‰ªéÊï∞ÊçÆÂàÜÊûê‰∏≠ÂèëÁé∞ÁöÑ‰∏öÂä°Ê¥ûÂØü"},
                    },
                    "required": ["insight"],
                },
            ),
        ]

    @server.call_tool()
    async def handle_call_tool(
        name: str, arguments: dict[str, Any] | None
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        """Â§ÑÁêÜÂ∑•ÂÖ∑ÊâßË°åËØ∑Ê±Ç"""
        try:
            if name == "list_tables":
                results = db._execute_query(
                    """
                    SELECT TABLE_NAME as name 
                    FROM INFORMATION_SCHEMA.TABLES 
                    WHERE TABLE_TYPE = 'BASE TABLE'
                    """
                )
                return [types.TextContent(type="text", text=str(results))]

            elif name == "describe_table":
                if not arguments or "table_name" not in arguments:
                    raise ValueError("Áº∫Â∞ë table_name ÂèÇÊï∞")
                results = db._execute_query(
                    """
                    SELECT 
                        COLUMN_NAME as name,
                        DATA_TYPE as type,
                        IS_NULLABLE as nullable,
                        COLUMN_DEFAULT as default_value
                    FROM INFORMATION_SCHEMA.COLUMNS
                    WHERE TABLE_NAME = ?
                    """,
                    {"table_name": arguments['table_name']}
                )
                return [types.TextContent(type="text", text=str(results))]

            elif name == "append_insight":
                if not arguments or "insight" not in arguments:
                    raise ValueError("Áº∫Â∞ë insight ÂèÇÊï∞")

                db.insights.append(arguments["insight"])
                _ = db._synthesize_memo()

                # ÈÄöÁü•ÂÆ¢Êà∑Á´ØÂ§áÂøòÂΩïËµÑÊ∫êÂ∑≤Êõ¥Êñ∞
                await server.request_context.session.send_resource_updated(AnyUrl("memo://insights"))

                return [types.TextContent(type="text", text="Ê¥ûÂØüÂ∑≤Ê∑ªÂä†Âà∞Â§áÂøòÂΩï")]

            if not arguments:
                raise ValueError("Áº∫Â∞ëÂèÇÊï∞")

            if name == "read_query":
                if not arguments["query"].strip().upper().startswith("SELECT"):
                    raise ValueError("read_query Âè™ÂÖÅËÆ∏ SELECT Êü•ËØ¢")
                results = db._execute_query(arguments["query"])
                return [types.TextContent(type="text", text=str(results))]

            elif name == "write_query":
                if arguments["query"].strip().upper().startswith("SELECT"):
                    raise ValueError("write_query ‰∏çÂÖÅËÆ∏ SELECT Êü•ËØ¢")
                results = db._execute_query(arguments["query"])
                return [types.TextContent(type="text", text=str(results))]

            elif name == "create_table":
                if not arguments["query"].strip().upper().startswith("CREATE TABLE"):
                    raise ValueError("Âè™ÂÖÅËÆ∏ CREATE TABLE ËØ≠Âè•")
                db._execute_query(arguments["query"])
                return [types.TextContent(type="text", text="Ë°®ÂàõÂª∫ÊàêÂäü")]

            else:
                raise ValueError(f"Êú™Áü•Â∑•ÂÖ∑: {name}")

        except pyodbc.Error as e:
            return [types.TextContent(type="text", text=f"Êï∞ÊçÆÂ∫ìÈîôËØØ: {str(e)}")]
        except Exception as e:
            return [types.TextContent(type="text", text=f"ÈîôËØØ: {str(e)}")]

    @server.list_prompts()
    async def handle_list_prompts() -> list[types.Prompt]:
        logger.debug("Â§ÑÁêÜ list_prompts ËØ∑Ê±Ç")
        return [
            types.Prompt(
                name="mcp-demo",
                description="‰∏Ä‰∏™Áî®‰∫éÂú® MSSQL Êï∞ÊçÆÂ∫ì‰∏≠ÂàõÂª∫ÂàùÂßãÊï∞ÊçÆÂπ∂ÊºîÁ§∫ MSSQL MCP ÊúçÂä°Âô®ÂäüËÉΩÁöÑÊèêÁ§∫",
                arguments=[
                    types.PromptArgument(
                        name="topic",
                        description="Áî®‰∫éÁîüÊàêÂàùÂßãÊï∞ÊçÆÁöÑ‰∏ªÈ¢ò",
                        required=True,
                    )
                ],
            )
        ]

    @server.get_prompt()
    async def handle_get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:
        logger.debug(f"Â§ÑÁêÜ get_prompt ËØ∑Ê±ÇÔºåÂêçÁß∞: {name}ÔºåÂèÇÊï∞: {arguments}")
        if name != "mcp-demo":
            logger.error(f"Êú™Áü•ÁöÑÊèêÁ§∫: {name}")
            raise ValueError(f"Êú™Áü•ÁöÑÊèêÁ§∫: {name}")

        if not arguments or "topic" not in arguments:
            logger.error("Áº∫Â∞ëÂøÖÈúÄÁöÑÂèÇÊï∞: topic")
            raise ValueError("Áº∫Â∞ëÂøÖÈúÄÁöÑÂèÇÊï∞: topic")

        topic = arguments["topic"]
        prompt = PROMPT_TEMPLATE.format(topic=topic)

        logger.debug(f"‰∏∫‰∏ªÈ¢ò {topic} ÁîüÊàêÊèêÁ§∫Ê®°Êùø")
        return types.GetPromptResult(
            description=f"‰∏ªÈ¢ò {topic} ÁöÑÊºîÁ§∫Ê®°Êùø",
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(type="text", text=prompt.strip()),
                )
            ],
        )

    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        logger.info("ÊúçÂä°Âô®Ê≠£Âú®‰ΩøÁî® stdio ‰º†ËæìËøêË°å")
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name=config.server_name,
                server_version=config.server_version,
                capabilities=server.get_capabilities(
                    notification_options=NotificationOptions(),
                    experimental_capabilities={},
                ),
            ),
        )

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
